<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>For Data Structure</h1>

网
<svg width="198" height="187" xmlns="http://www.w3.org/2000/svg">
 <g>
  <title>Layer 1</title>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_1" y="15.2" x="99.79997" stroke-width="0" stroke="#000" fill="#000000">V1</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_2" y="73.2" x="0.79997" stroke-width="0" stroke="#000" fill="#000000">V2</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_3" y="108.2" x="90.79997" stroke-width="0" stroke="#000" fill="#000000">V3</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_4" y="71.2" x="176.79997" stroke-width="0" stroke="#000" fill="#000000">V4</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_5" y="170.2" x="21.79997" stroke-width="0" stroke="#000" fill="#000000">V5</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="17" id="svg_6" y="172.2" x="151.79997" stroke-width="0" stroke="#000" fill="#000000">V6</text>
  <line stroke="#000" id="svg_7" y2="60.2" x2="26.79998" y1="14.2" x1="96.79998" fill="none"/>
  <line id="svg_8" y2="87.2" x2="103.79997" y1="20.2" x1="109.79997" stroke="#000" fill="none"/>
  <line stroke="#000" id="svg_9" y2="53.2" x2="179.79997" y1="15.2" x1="126.79997" fill="none"/>
  <line id="svg_10" y2="146.2" x2="31.79997" y1="80.2" x1="11.79997" stroke="#000" fill="none"/>
  <line id="svg_11" y2="154.2" x2="47.79997" y1="112.2" x1="91.79997" stroke="#000" fill="none"/>
  <line stroke="#000" id="svg_12" y2="155.2" x2="151.79997" y1="114.2" x1="108.79997" fill="none"/>
  <line id="svg_13" y2="78.2" x2="186.79997" y1="155.2" x1="170.79997" stroke="#000" fill="none"/>
  <line id="svg_14" y2="166.2" x2="143.79997" y1="163.2" x1="47.79997" stroke="#000" fill="none"/>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" stroke-width="0" id="svg_15" y="28.2" x="47.79997" stroke="#000" fill="#000000">6</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_16" y="27.2" x="160.79997" stroke-width="0" stroke="#000" fill="#000000">5</text>
  <line id="svg_17" y2="96.2" x2="82.79997" y1="72.2" x1="27.79997" stroke="#000" fill="none"/>
  <line id="svg_18" y2="70.2" x2="171.79997" y1="101.2" x1="115.79997" stroke="#000" fill="none"/>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_19" y="78.2" x="59.79997" stroke-width="0" stroke="#000" fill="#000000">5</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_20" y="57.2" x="91.79997" stroke-width="0" stroke="#000" fill="#000000">1</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_21" y="76.2" x="137.79997" stroke-width="0" stroke="#000" fill="#000000">5</text>
  <text stroke="#000" xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_22" y="129.2" x="7.79997" stroke-width="0" fill="#000000">3</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_23" y="124.2" x="59.79997" stroke-width="0" stroke="#000" fill="#000000">6</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_24" y="184.2" x="88.79997" stroke-width="0" stroke="#000" fill="#000000">6</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_25" y="145.2" x="114.79997" stroke-width="0" stroke="#000" fill="#000000">4</text>
  <text xml:space="preserve" text-anchor="start" font-family="Noto Sans JP" font-size="14" id="svg_26" y="125.2" x="182.79997" stroke-width="0" stroke="#000" fill="#000000">2</text>
 </g>
</svg>


    <ul>
      <li>求解网的最小生成树(Minimal Spanning Tree)</li>
    </ul>

    <script>
      /* 求解网的最小生成树(Minimal Spanning Tree) */

      // 网，边上带有权值的无向图
      // 采用邻接矩阵存储结构
      function Network(vexes, edges) {
        this.vexes = vexes; // 一维数组保存所有顶点
        this.edges = edges; // 二维数组保存边，数组的值表示边上的权值, '-1'表示两个顶点不连通
      }

      // 返回该网的最小生成树（普利姆Prim算法）
      /* 设集合U为全部顶点的集合V的非空子集，集合U初始仅包含一个顶点，反复寻找集合U与V-U之间权值最小的边，并将
      集合V-U中最小的边的端点加入U中，然后再次寻找。直至U == V */
      Network.prototype.mst_Prim = function () {
        // 用于计算结点间最小权值的数组
        // 索引对应于顶点数组，数组中的元素结构为: { vexIndex: 与当前索引表示的顶点构成最小权值的边的顶点的索引, weight: 权值 }
        const weights = new Array(this.vexes.length);

        // 从第一个顶点开始，该点构成初始的集合U，U中的所有顶点的权值均为0
        weights[0] = { vexIndex: null, weight: 0 };
        let lastMinimal = 0; // 上一个与集合U中顶点权值最小的边，这个边的在集合V-U中的邻接点的索引
        let remainingVex = this.vexes.length - 1; // V-U中剩余顶点个数，每找到一个最小权值的边，V-U中就减少一个顶点

        /* 循环查找U与V-U中权值最小的边，并将V-U中的顶点加入U中
        第一次查找时，将计算V-U中所有顶点与U中的唯一顶点的权值并找到最小权值
        第二次查找时，由于上一次已经计算了V-U中与U中第一个顶点的权值，本次仅需要计算V-U中与U中第二个顶点
        （也就是上一次查找时得到的顶点）的权值，并将权值与上一次的权值比对。如果比上一次权值小则保留本次权值，否则不做任何操作。 */
        while (remainingVex) {
          /* 计算V-U与U中顶点的边的权值，并保留较小的权值 */
          for (let i = 1; i < weights.length; i++) {
            if (weights[i] == null) {
              weights[i] = { vexIndex: null, weight: Number.MAX_VALUE };
            }

            if (weights[i].weight === 0) continue; // 忽略已在集合U中的顶点

            const iWeight = this.edges[lastMinimal][i];
            if (iWeight && weights[i].weight > iWeight) { // 对比上次权值，选择更小的权值
              weights[i].weight = iWeight;
              weights[i].vexIndex = lastMinimal;
            }
          }

          const w = minimalWeight(weights);
          weights[w].weight = 0;
          lastMinimal = w;

          remainingVex--;
        }

        const mstEdges = []; // 最小生成树所有的边
        for (let i = 1; i < weights.length; i++) {
          mstEdges.push([this.vexes[i], this.vexes[weights[i].vexIndex]]);
        }

        return mstEdges;

        function minimalWeight(weights) {
          let w; // V-U中最小权值边的顶点索引
          for (let i = 0; i < weights.length; i++) {
            if (weights[i].weight === 0) continue;

            if (w == null || weights[w].weight > weights[i].weight) {
              w = i;
            }
          }

          if (w == null) throw new Error('error!');

          return w;
        }
      };

      const vexes = ['V1', 'V2', 'V3', 'V4', 'V5', 'V6'];
      const edges = new Array(vexes.length);
      for (let i = 0; i < edges.length; i++) {
        edges[i] = new Array(vexes.length);
      }
      edges[0][1] = edges[1][0] = 6;
      edges[0][2] = edges[2][0] = 1;
      edges[0][3] = edges[3][0] = 5;

      edges[1][4] = edges[4][1] = 3;
      edges[1][2] = edges[2][1] = 5;

      edges[2][4] = edges[4][2] = 6;
      edges[2][5] = edges[5][2] = 4;
      edges[2][3] = edges[3][2] = 5;

      edges[4][5] = edges[5][4] = 6;
      edges[5][3] = edges[3][5] = 2;

      const n0 = new Network(vexes, edges);
      const mstEdges = n0.mst_Prim();
      console.log('mstEdges: ', mstEdges);
    </script>
  </body>
</html>
