<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>For Data Structure</h1>
    <pre>
无向图
 A ---------- B                                
 |            |                                
 |            |        F -------- G            
 |            |                                
 |            |                                
 |            |                                
 D ---------- C                                
  \           /                                
   \         /                                 
    \       /                                  
     \     /                                   
      - E - 
    
有向图
                    
     A              
    / \             
   /   \            
  /     \           
 v       v          
 B ----> C ------> D
 ^                 |
 |                 |
 |-----------------+
    </pre>
    <ul>
      <li>根据无向图的连通分量创建生成森林（以二叉链表表示）</li>
      <li>计算有向图的强连通分量的顶点集</li>
    </ul>
    <script>
      /* 根据无向图的连通分量创建生成森林（以二叉链表表示） */

      /* 用邻接多重表表示图，二叉链表表示生成森林，采用深度优先遍历创建生成树 */

      /* 图，'vexes'表示所有顶点构成的一维数组 */
      function Graph(vexes) {
        this.vexes = vexes;
      }
      Graph.prototype.pos = function (data) {
        return this.vexes.findIndex(v => v.data === data);
      };
      Graph.prototype.vex = function (data) {
        return this.vexes.find(v => v.data === data);
      };
      Graph.prototype.initEdges = function (edges) {
        for (const e of edges) {
          const { xVex, yVex } = e;
          const [x, y] = [this.vexes[xVex], this.vexes[yVex]];

          e.xNext = x.firstEdge;
          x.firstEdge = e;
          e.yNext = y.firstEdge;
          y.firstEdge = e;
        }
      };
      Graph.prototype.firstAdj = function (v) {
        const i = this.vexes.indexOf(v);
        const { xVex, yVex } = v.firstEdge;

        if (xVex === i) return this.vexes[yVex];

        if (yVex === i) return this.vexes[xVex];
      };
      Graph.prototype.nextAdj = function (v, adj) {
        const i = this.vexes.indexOf(v);

        let found = false;
        for (let e = v.firstEdge; e; ) {
          const { xVex, xNext, yVex, yNext } = e;

          if (found) {
            // 已找到当前邻接点adj的下一条边
            if (xVex === i) return this.vexes[yVex];

            if (yVex === i) return this.vexes[xVex];
          }

          if (xVex === i) {
            found = this.vexes[yVex] === adj;
            e = xNext;
            continue;
          }

          if (yVex === i) {
            found = this.vexes[xVex] === adj;
            e = yNext;
            continue;
          }
        }

        // 没找到adj的下一个邻接点，或者adj是最后一个邻接点
        return null;
      };
      /* 顶点 */
      function Vertex(data) {
        this.data = data; // 顶点表示的值
        this.firstEdge = null; // 与该顶点相关联的第一条边
      }
      /* 边 */
      function Edge(xVex, yVex) {
        this.xVex = xVex; // x端的顶点索引
        this.yVex = yVex; // y端的顶点索引
        this.xNext = null; // x端的下一条边
        this.yNext = null; // y端的下一条边
      }
      /* 森林中树的结点，以二叉链表结构保存 */
      function TreeNode(data, firstChild, nextSibling) {
        this.data = data; // 树结点表示的值
        this.firstChild = firstChild; // 树结点的第一个孩子结点
        this.nextSibling = nextSibling; // 树结点的下一个兄弟结点
      }

      const vexes = [new Vertex('a'), new Vertex('b'), new Vertex('c'), new Vertex('d'), new Vertex('e'), new Vertex('f'), new Vertex('g')];
      const g0 = new Graph(vexes);

      const edges = [
        new Edge(g0.pos('a'), g0.pos('b')),
        new Edge(g0.pos('b'), g0.pos('c')),
        new Edge(g0.pos('c'), g0.pos('d')),
        new Edge(g0.pos('a'), g0.pos('d')),
        new Edge(g0.pos('d'), g0.pos('e')),
        new Edge(g0.pos('e'), g0.pos('c')),
        new Edge(g0.pos('f'), g0.pos('g')),
      ];
      g0.initEdges(edges);

      const root = forestFromGraph(g0);
      console.log(root);

      /* 根据无向图g的"深度优先遍历"创建生成森林 */
      function forestFromGraph(g) {
        const visited = new Array(g.vexes.length);
        let forestRoot = null; // 森林的树根
        let lastRoot = null; // 保存上一个已遍历的连通分量的树根

        for (let vIndex = 0; vIndex < g.vexes.length; vIndex++) {
          if (visited[vIndex]) continue; // 如果图中某一顶点已遍历，则所有与该顶点连通的顶点均已被遍历

          const v = g.vexes[vIndex]; // 该未遍历的顶点将成为森林中一棵树的树根
          // 准备创建生成树
          const treeRoot = new TreeNode(v.data);
          if (!lastRoot) {
            // 森林二叉树的树根为第一棵树的树根
            forestRoot = lastRoot = treeRoot;
          } else {
            // 森林中其他树构成第一棵树的右子树
            lastRoot.nextSibling = treeRoot;
            lastRoot = treeRoot;
          }

          // 从顶点开始深度优先遍历, 并根据该顶点所在的连通分量创建一棵生成树
          spTreeFromDFS(g, v, lastRoot);
        }

        return forestRoot;

        // 根据深度优先遍历创建生成树
        // v: 图中的顶点，parent: v对应的生成树中的树根
        function spTreeFromDFS(g, v, parent) {
          const vIndex = g.vexes.indexOf(v);
          visited[vIndex] = true;

          let isFirstAdj = true;
          for (let adj = g.firstAdj(v); adj; adj = g.nextAdj(v, adj)) {
            const adjIndex = g.vexes.indexOf(adj);

            if (visited[adjIndex]) continue;

            visited[adjIndex] = true;

            if (isFirstAdj) {
              // 顶点的第一个邻接点将变成左子结点
              isFirstAdj = false;
              parent.firstChild = new TreeNode(adj.data);
              parent = parent.firstChild;
            } else {
              // 顶点的后续邻接点将变成左子结点的右子结点
              parent.nextSibling = new TreeNode(adj.data);
              parent = parent.nextSibling;
            }

            spTreeFromDFS(g, adj, parent); // 递归遍历邻接点
          }
        }
      }
    </script>

    <script>
      /* 计算有向图的强连通分量的顶点集 */

      /* 有向图，十字链表表示法 */
      function DGraph(vexes) {
        this.vexes = vexes;
      }
      /* 有向图的弧 */
      function Arc(tail, head) {
        this.head = head; // 弧头，顶点在数组中的索引
        this.tail = tail; // 弧尾，顶点在数组中的索引
        this.headNext = null; // 相同弧头的下一条弧
        this.tailNext = null; // 相同弧尾的下一条弧
      }
      /* 有向图的顶点 */
      function DVertex(data) {
        this.data = data;
        this.firstIn = null; // 顶点的第一条入弧
        this.firstOut = null; // 顶点的第一条出弧
      }
      DGraph.prototype.pos = function (data) {
        return this.vexes.findIndex(v => v.data === data);
      };
      DGraph.prototype.vex = function (data) {
        return this.vexes.find(v => v.data === data);
      };
      DGraph.prototype.initArcs = function (arcs) {
        for (const a of arcs) {
          const { head, tail } = a;
          const [vHead, vTail] = [this.vexes[head], this.vexes[tail]];

          a.headNext = vHead.firstIn;
          a.tailNext = vTail.firstOut;
          vHead.firstIn = vTail.firstOut = a;
        }
      };
      /* 获取顶点的第一个邻接点, 'isIn === true'表示入弧邻接点，否则为出弧邻接点 */
      DGraph.prototype.firstAdj = function (v, isIn) {
        const arc = isIn ? v.firstIn : v.firstOut;
        if (!arc) return null;

        return isIn ? this.vexes[arc.tail] : this.vexes[arc.head];
      };
      /* 获取相对于邻接点adj的下一个邻接点，'isIn'同上 */
      DGraph.prototype.nextAdj = function (v, adj, isIn) {
        const adjIndex = this.vexes.indexOf(adj);

        let found = false;
        if (isIn) {
          for (let a = v.firstIn; a; a = a.headNext) {
            if (found) return this.vexes[a.tail];

            found = a.tail === adjIndex;
          }
          return null;
        }

        // isIn === false
        for (let a = v.firstOut; a; a = a.tailNext) {
          if (found) return this.vexes[a.head];

          found = a.head === adjIndex;
        }
        return null;
      };

      const dvexes = [new DVertex('A'), new DVertex('B'), new DVertex('C'), new DVertex('D')];
      const g1 = new DGraph(dvexes);
      console.log(g1);
      const arcs = [
        new Arc(g1.pos('A'), g1.pos('B')),
        new Arc(g1.pos('A'), g1.pos('C')),
        new Arc(g1.pos('B'), g1.pos('C')),
        new Arc(g1.pos('C'), g1.pos('D')),
        new Arc(g1.pos('D'), g1.pos('B')),
      ];
      g1.initArcs(arcs);

      const scc = calcSCComponent(g1);

      console.log('scc: ', scc);

      /* 计算有向图的强连通分量(Strongly Connected Component)的顶点集 */
      function calcSCComponent(dg) {
        const visited = new Array(dg.vexes.length); // 保存有向图中所有顶点的访问状态
        // 保存dfs遍历时产生的多个子图的顶点集，而且顶点集按照递归顺序排列，子图中的顶点在一次dfs过程中均可被访问
        const subDG = [];

        /* 先以顺序（弧尾 => 弧头）方向遍历有向图，如果是非强连通图遍历时会出现多个子图 */
        for (let v of dg.vexes) {
          const vIndex = dg.vexes.indexOf(v);
          if (visited[vIndex]) continue;

          const finishedV = [];
          subDG.push(finishedV); // 保存每个子图
          dfs(dg, v, dg.vexes, visited, finishedV, true); // 从顶点v开始dfs顺序遍历
        }

        const sccomponents = []; // 保存所有的强连通分量
        /* 以逆序（弧头 => 弧尾）遍历每一个子图 */
        for (const finishedV of subDG) {
          const subVisited = new Array(finishedV.length); // 记录每个子图遍历时顶点是否已访问的状态

          for (let i = finishedV.length - 1; i >= 0; i--) {
            if (subVisited[i]) continue;

            /* 逆序遍历每一个子图时仍可能出现多个子图，出现的每一个子图就是有向图dg的强连通分量 */
            const lastV = finishedV[i];
            const subFinished = []; // 记录逆序遍历时经过的每个顶点
            dfs(dg, lastV, finishedV, subVisited, subFinished, false);
            sccomponents.push(subFinished); // 每次逆序遍历子图所经过的点都是一个强连通分量的顶点集
          }
        }

        return sccomponents;

        // 深度遍历图dg，并记录遍历时所经过的顶点
        /* 
          v：遍历的起始顶点
          vexes：顶点v所在的顶点数组
          visited：记录顶点数组中每个顶点是否已访问的状态
            注意，vexes与visited必须相对应，即visited的索引一定表示vexes中对应的顶点，
          finishedV：保存遍历时所经过的顶点，以递归的顺序保存，即最先访问的顶点为数组最后一个元素
          tailToHead：当按照从弧尾到弧头的方向遍历时为true, 反之为false 
        */
        function dfs(dg, v, vexes, visited, finishedV, tailToHead) {
          const vIndex = vexes.indexOf(v);
          if (visited[vIndex]) return;

          visited[vIndex] = true;
          for (let adj = dg.firstAdj(v, !tailToHead); adj; adj = dg.nextAdj(v, adj, !tailToHead)) {
            dfs(dg, adj, vexes, visited, finishedV, tailToHead);
          }

          finishedV.push(v); // 按递归顺序记录被遍历的顶点
        }
      }
    </script>
  </body>
</html>
